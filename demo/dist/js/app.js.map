{
  "version": 3,
  "sources": ["../../../node_modules/@babel/runtime/helpers/arrayLikeToArray.js", "../../../node_modules/@babel/runtime/helpers/arrayWithoutHoles.js", "../../../node_modules/@babel/runtime/helpers/iterableToArray.js", "../../../node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js", "../../../node_modules/@babel/runtime/helpers/nonIterableSpread.js", "../../../node_modules/@babel/runtime/helpers/toConsumableArray.js", "../../../node_modules/@babel/runtime/helpers/arrayWithHoles.js", "../../../node_modules/@babel/runtime/helpers/iterableToArrayLimit.js", "../../../node_modules/@babel/runtime/helpers/nonIterableRest.js", "../../../node_modules/@babel/runtime/helpers/slicedToArray.js", "../../../node_modules/@babel/runtime/helpers/classCallCheck.js", "../../../node_modules/@babel/runtime/helpers/createClass.js", "../../../node_modules/@babel/runtime/helpers/setPrototypeOf.js", "../../../node_modules/@babel/runtime/helpers/inherits.js", "../../../node_modules/@babel/runtime/helpers/typeof.js", "../../../node_modules/@babel/runtime/helpers/assertThisInitialized.js", "../../../node_modules/@babel/runtime/helpers/possibleConstructorReturn.js", "../../../node_modules/@babel/runtime/helpers/getPrototypeOf.js", "../../../node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js", "../../../node_modules/@babel/runtime/helpers/objectWithoutProperties.js", "../../../node_modules/nanoid/non-secure/index.js", "../../../node_modules/@babel/runtime/helpers/defineProperty.js", "../../../node_modules/deepmerge/dist/cjs.js", "../../src/js/app.js", "../../../node_modules/@studiometa/src/abstracts/Base/index.js", "../../../node_modules/@studiometa/src/utils/object/getAllProperties.js", "../../../node_modules/@studiometa/src/utils/object/autoBind.js", "../../../node_modules/@studiometa/src/abstracts/EventManager.js", "../../../node_modules/@studiometa/src/abstracts/Base/utils.js", "../../../node_modules/@studiometa/src/abstracts/Base/children.js", "../../../node_modules/@studiometa/src/abstracts/Base/options.js", "../../../node_modules/@studiometa/src/abstracts/Base/refs.js", "../../../node_modules/@studiometa/src/abstracts/Base/components.js", "../../../node_modules/@studiometa/src/abstracts/Service.js", "../../../node_modules/@studiometa/src/utils/throttle.js", "../../../node_modules/@studiometa/src/utils/debounce.js", "../../../node_modules/@studiometa/src/utils/nextFrame.js", "../../../node_modules/@studiometa/src/services/raf.js", "../../../node_modules/@studiometa/src/services/pointer.js", "../../../node_modules/@studiometa/src/services/resize.js", "../../../node_modules/@studiometa/src/services/scroll.js", "../../../node_modules/@studiometa/src/utils/keyCodes.js", "../../../node_modules/@studiometa/src/services/key.js", "../../../node_modules/@studiometa/src/abstracts/Base/services.js", "../../../node_modules/@studiometa/src/abstracts/Base/events.js", "../../../node_modules/@studiometa/src/abstracts/Base/index.js", "../../../node_modules/@studiometa/src/abstracts/Base/index.js", "../../../node_modules/@studiometa/src/index.js"],
  "sourcesContent": ["function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nmodule.exports = _arrayLikeToArray;", "var arrayLikeToArray = require(\"./arrayLikeToArray\");\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}\n\nmodule.exports = _arrayWithoutHoles;", "function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nmodule.exports = _iterableToArray;", "var arrayLikeToArray = require(\"./arrayLikeToArray\");\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\n\nmodule.exports = _unsupportedIterableToArray;", "function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nmodule.exports = _nonIterableSpread;", "var arrayWithoutHoles = require(\"./arrayWithoutHoles\");\n\nvar iterableToArray = require(\"./iterableToArray\");\n\nvar unsupportedIterableToArray = require(\"./unsupportedIterableToArray\");\n\nvar nonIterableSpread = require(\"./nonIterableSpread\");\n\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}\n\nmodule.exports = _toConsumableArray;", "function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nmodule.exports = _arrayWithHoles;", "function _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nmodule.exports = _iterableToArrayLimit;", "function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nmodule.exports = _nonIterableRest;", "var arrayWithHoles = require(\"./arrayWithHoles\");\n\nvar iterableToArrayLimit = require(\"./iterableToArrayLimit\");\n\nvar unsupportedIterableToArray = require(\"./unsupportedIterableToArray\");\n\nvar nonIterableRest = require(\"./nonIterableRest\");\n\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}\n\nmodule.exports = _slicedToArray;", "function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;", "function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;", "function _setPrototypeOf(o, p) {\n  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nmodule.exports = _setPrototypeOf;", "var setPrototypeOf = require(\"./setPrototypeOf\");\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}\n\nmodule.exports = _inherits;", "function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;", "function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nmodule.exports = _assertThisInitialized;", "var _typeof = require(\"@babel/runtime/helpers/typeof\");\n\nvar assertThisInitialized = require(\"./assertThisInitialized\");\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}\n\nmodule.exports = _possibleConstructorReturn;", "function _getPrototypeOf(o) {\n  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nmodule.exports = _getPrototypeOf;", "function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nmodule.exports = _objectWithoutPropertiesLoose;", "var objectWithoutPropertiesLoose = require(\"./objectWithoutPropertiesLoose\");\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nmodule.exports = _objectWithoutProperties;", "// This alphabet uses a-z A-Z 0-9 _- symbols.\n// Symbols are generated for smaller size.\n// -_zyxwvutsrqponmlkjihgfedcba9876543210ZYXWVUTSRQPONMLKJIHGFEDCBA\nvar url = '-_'\n// Loop from 36 to 0 (from z to a and 9 to 0 in Base36).\nvar i = 36\nwhile (i--) {\n  // 36 is radix. Number.prototype.toString(36) returns number\n  // in Base36 representation. Base36 is like hex, but it uses 0\u20139 and a-z.\n  url += i.toString(36)\n}\n// Loop from 36 to 10 (from Z to A in Base36).\ni = 36\nwhile (i-- - 10) {\n  url += i.toString(36).toUpperCase()\n}\n\n/**\n * Generate URL-friendly unique ID. This method use non-secure predictable\n * random generator with bigger collision probability.\n *\n * @param {number} [size=21] The number of symbols in ID.\n *\n * @return {string} Random string.\n *\n * @example\n * const nanoid = require('nanoid/non-secure')\n * model.id = nanoid() //=> \"Uakgb_J5m9g-0JDMbcJqL\"\n *\n * @name nonSecure\n * @function\n */\nmodule.exports = function (size) {\n  var id = ''\n  i = size || 21\n  // Compact alternative for `for (var i = 0; i < size; i++)`\n  while (i--) {\n    // `| 0` is compact and faster alternative for `Math.floor()`\n    id += url[Math.random() * 64 | 0]\n  }\n  return id\n}\n", "function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;", "'use strict';\n\nvar isMergeableObject = function isMergeableObject(value) {\n\treturn isNonNullObject(value)\n\t\t&& !isSpecial(value)\n};\n\nfunction isNonNullObject(value) {\n\treturn !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n\tvar stringValue = Object.prototype.toString.call(value);\n\n\treturn stringValue === '[object RegExp]'\n\t\t|| stringValue === '[object Date]'\n\t\t|| isReactElement(value)\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\n}\n\nfunction emptyTarget(val) {\n\treturn Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n\treturn (options.clone !== false && options.isMergeableObject(value))\n\t\t? deepmerge(emptyTarget(value), value, options)\n\t\t: value\n}\n\nfunction defaultArrayMerge(target, source, options) {\n\treturn target.concat(source).map(function(element) {\n\t\treturn cloneUnlessOtherwiseSpecified(element, options)\n\t})\n}\n\nfunction getMergeFunction(key, options) {\n\tif (!options.customMerge) {\n\t\treturn deepmerge\n\t}\n\tvar customMerge = options.customMerge(key);\n\treturn typeof customMerge === 'function' ? customMerge : deepmerge\n}\n\nfunction getEnumerableOwnPropertySymbols(target) {\n\treturn Object.getOwnPropertySymbols\n\t\t? Object.getOwnPropertySymbols(target).filter(function(symbol) {\n\t\t\treturn target.propertyIsEnumerable(symbol)\n\t\t})\n\t\t: []\n}\n\nfunction getKeys(target) {\n\treturn Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))\n}\n\nfunction propertyIsOnObject(object, property) {\n\ttry {\n\t\treturn property in object\n\t} catch(_) {\n\t\treturn false\n\t}\n}\n\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\nfunction propertyIsUnsafe(target, key) {\n\treturn propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n\t\t&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n\t\t\t&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.\n}\n\nfunction mergeObject(target, source, options) {\n\tvar destination = {};\n\tif (options.isMergeableObject(target)) {\n\t\tgetKeys(target).forEach(function(key) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n\t\t});\n\t}\n\tgetKeys(source).forEach(function(key) {\n\t\tif (propertyIsUnsafe(target, key)) {\n\t\t\treturn\n\t\t}\n\n\t\tif (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n\t\t\tdestination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n\t\t} else {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n\t\t}\n\t});\n\treturn destination\n}\n\nfunction deepmerge(target, source, options) {\n\toptions = options || {};\n\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\n\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\t// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n\t// implementations can use it. The caller may not replace it.\n\toptions.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n\n\tvar sourceIsArray = Array.isArray(source);\n\tvar targetIsArray = Array.isArray(target);\n\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\tif (!sourceAndTargetTypesMatch) {\n\t\treturn cloneUnlessOtherwiseSpecified(source, options)\n\t} else if (sourceIsArray) {\n\t\treturn options.arrayMerge(target, source, options)\n\t} else {\n\t\treturn mergeObject(target, source, options)\n\t}\n}\n\ndeepmerge.all = function deepmergeAll(array, options) {\n\tif (!Array.isArray(array)) {\n\t\tthrow new Error('first argument should be an array')\n\t}\n\n\treturn array.reduce(function(prev, next) {\n\t\treturn deepmerge(prev, next, options)\n\t}, {})\n};\n\nvar deepmerge_1 = deepmerge;\n\nmodule.exports = deepmerge_1;\n", "import Base from '@studiometa/js-toolkit';\n\nclass App extends Base {\n\tget config() {\n\t\treturn {\n\t\t\tname: 'App',\n\t\t};\n\t}\n}\n\nexport default new App(document.body);", "import nanoid from 'nanoid/non-secure';\nimport autoBind from '../../utils/object/autoBind';\nimport EventManager from '../EventManager';\nimport { callMethod, debug } from './utils';\nimport { getChildren, getComponentElements } from './children';\nimport { getOptions, setOptions } from './options';\nimport { getRefs } from './refs';\nimport { mountComponents, destroyComponents } from './components';\nimport bindServices from './services';\nimport bindEvents from './events';\n\n/**\n * Page lifecycle class\n *\n * @method mounted   Fired when the class is instantiated\n * @method loaded    Fired on the window's load event\n * @method ticked    Fired each frame with `requestAnimationFrame`\n * @method resized   Fired when the window is resized (`resize` event)\n * @method moved     Fired when the pointer has moved (`touchmove` and `mousemove` events)\n * @method scrolled  Fired with debounce when the document is scrolled (`scroll` event)\n * @method destroyed Fired when the window is being unloaded (`unload` event)\n */\nexport default class Base extends EventManager {\n  /**\n   * Get the component's refs.\n   * @return {Object}\n   */\n  get $refs() {\n    return getRefs(this, this.$el);\n  }\n\n  /**\n   * Get the component's children components.\n   * @return {Object}\n   */\n  get $children() {\n    return getChildren(this, this.$el, this.config.components || {});\n  }\n\n  /**\n   * Get the component's merged config and options.\n   * @return {Object}\n   */\n  get $options() {\n    return getOptions(this, this.$el, this.config);\n  }\n\n  /**\n   * Set the components option.\n   * @param  {Object} value The new options values to merge with the old ones.\n   * @return {void}\n   */\n  set $options(newOptions) {\n    setOptions(this, this.$el, newOptions);\n  }\n\n  /**\n   * Class constructor where all the magic takes place.\n   *\n   * @param  {HTMLElement} element The component's root element.\n   * @return {Base}                A Base instance.\n   */\n  constructor(element) {\n    super();\n\n    if (!this.config) {\n      throw new Error('The `config` getter must be defined.');\n    }\n\n    if (!this.config.name) {\n      throw new Error('The `config.name` property is required.');\n    }\n\n    if (!element) {\n      throw new Error('The root element must be defined.');\n    }\n\n    Object.defineProperties(this, {\n      $id: {\n        value: `${this.config.name}-${nanoid()}`,\n      },\n      $isMounted: {\n        value: false,\n        writable: true,\n      },\n      $el: {\n        value: element,\n      },\n    });\n\n    if (!this.$el.__base__) {\n      Object.defineProperty(this.$el, '__base__', {\n        get: () => this,\n        configurable: true,\n      });\n    }\n\n    // Autobind all methods to the instance\n    autoBind(this, {\n      exclude: [\n        '$mount',\n        '$update',\n        '$destroy',\n        '$terminate',\n        '$log',\n        '$on',\n        '$once',\n        '$off',\n        '$emit',\n        'mounted',\n        'loaded',\n        'ticked',\n        'resized',\n        'moved',\n        'keyed',\n        'scrolled',\n        'destroyed',\n        'terminated',\n        ...(this._excludeFromAutoBind || []),\n      ],\n    });\n\n    let unbindMethods = [];\n    this.$on('mounted', () => {\n      mountComponents(this);\n      unbindMethods = [...bindServices(this), ...bindEvents(this)];\n      this.$isMounted = true;\n    });\n\n    this.$on('updated', () => {\n      unbindMethods.forEach((method) => method());\n      mountComponents(this);\n      unbindMethods = [...bindServices(this), ...bindEvents(this)];\n    });\n\n    this.$on('destroyed', () => {\n      this.$isMounted = false;\n      unbindMethods.forEach((method) => method());\n      destroyComponents(this);\n    });\n\n    // Mount class which are not used as another component's child.\n    if (!this.__isChild__) {\n      this.$mount();\n      Object.defineProperty(this, '$parent', { get: () => null });\n    }\n\n    debug(this, 'constructor', this);\n    return this;\n  }\n\n  /**\n   * Small helper to log stuff.\n   *\n   * @param  {...any} args The arguments passed to the method\n   * @return {void}\n   */\n  $log(...args) {\n    return this.$options.log\n      ? window.console.log.apply(window, [this.config.name, ...args])\n      : () => {};\n  }\n\n  /**\n   * Trigger the `mounted` callback.\n   */\n  $mount() {\n    debug(this, '$mount');\n    callMethod(this, 'mounted');\n    return this;\n  }\n\n  /**\n   * Update the instance children.\n   */\n  $update() {\n    debug(this, '$update');\n    callMethod(this, 'updated');\n    return this;\n  }\n\n  /**\n   * Trigger the `destroyed` callback.\n   */\n  $destroy() {\n    debug(this, '$destroy');\n    callMethod(this, 'destroyed');\n    return this;\n  }\n\n  /**\n   * Terminate a child instance when it is not needed anymore.\n   * @return {void}\n   */\n  $terminate() {\n    debug(this, '$terminate');\n\n    // First, destroy the component.\n    this.$destroy();\n\n    // Execute the `terminated` hook if it exists\n    callMethod(this, 'terminated');\n\n    // Delete the reference to the instance\n    delete this.$el.__base__;\n\n    // And update its status to prevent re-instantiation when accessing the\n    // parent's `$children` property\n    Object.defineProperty(this.$el, '__base__', {\n      value: 'terminated',\n      configurable: false,\n      writable: false,\n    });\n  }\n\n  /**\n   * Factory method to generate multiple instance of the class.\n   *\n   * @param  {String}      selector The selector on which to mount each instance.\n   * @return {Array<Base>}          A list of the created instance.\n   */\n  static $factory(nameOrSelector) {\n    if (!nameOrSelector) {\n      throw new Error(\n        'The $factory method requires a component\u2019s name or selector to be specified.'\n      );\n    }\n\n    return getComponentElements(nameOrSelector).map((el) => new this(el));\n  }\n}\n\nBase.__isBase__ = true;\n", "/**\n * Gets all non-builtin properties up the prototype chain.\n *\n * @param  {Object} object The object to get the propeties from.\n * @param  {Array}  props  The already existing properties.\n * @return {Array}         An array of properties and their value.\n */\nexport default function getAllProperties(object, props = []) {\n  const proto = Object.getPrototypeOf(object);\n\n  if (proto === Object.prototype) {\n    return props;\n  }\n\n  return getAllProperties(\n    proto,\n    Object.getOwnPropertyNames(proto)\n      .map((name) => [name, proto])\n      .reduce((acc, val) => [...acc, val], props)\n  );\n}\n", "import getAllProperties from './getAllProperties';\n\n/**\n * Auto-bind methods to an instance.\n *\n * @param  {Object}               instance        The instance.\n * @param  {Array<String|RegExp>} options.include Methods to include.\n * @param  {Array<String|RegExp>} options.exclude Methods to exclude.\n * @return {Object}                               The instance.\n */\nexport default function autoBind(instance, { include, exclude } = {}) {\n  const filter = (key) => {\n    const match = (pattern) => (typeof pattern === 'string' ? key === pattern : pattern.test(key));\n\n    if (include) {\n      return include.some(match);\n    }\n\n    if (exclude) {\n      return !exclude.some(match);\n    }\n\n    return true;\n  };\n\n  getAllProperties(instance)\n    .filter(([key]) => key !== 'constructor' && filter(key))\n    .forEach(([key, object]) => {\n      const descriptor = Object.getOwnPropertyDescriptor(object, key);\n      if (descriptor && typeof descriptor.value === 'function') {\n        instance[key] = instance[key].bind(instance);\n      }\n    });\n\n  return instance;\n}\n", "/* eslint no-underscore-dangle: [\"error\", { \"allow\": [\"_events\"] }] */\n/**\n * Event management class.\n *\n * @method $on    Bind a given function to the given event.\n * @method $off   Unbind the given function from the given event.\n * @method $once  Bind a given function to the given event once.\n * @method $emit  Emit an event with custom props.\n */\nexport default class EventManager {\n  /** @type {Object} An object to store the events */\n  _events = {};\n\n  /**\n   * Bind a listener function to an event.\n   *\n   * @param  {String}   event    Name of the event.\n   * @param  {String}   listener Function to be called.\n   * @return {Function}          A function to unbind the listener.\n   */\n  $on(event, listener) {\n    if (!Array.isArray(this._events[event])) {\n      this._events[event] = [];\n    }\n    this._events[event].push(listener);\n\n    return () => {\n      this.$off(event, listener);\n    };\n  }\n\n  /**\n   * Unbind a listener function from an event.\n   *\n   * @param  {String}       event    Name of the event.\n   * @param  {String}       listener Function to be removed.\n   * @return {EventManager}          The current instance.\n   */\n  $off(event, listener) {\n    // If no event specified, we remove them all.\n    if (!event) {\n      this._events = {};\n      return this;\n    }\n    // If no listener have been specified, we remove all\n    // the listeners for the given event.\n    if (!listener) {\n      this._events[event] = [];\n      return this;\n    }\n\n    const index = this._events[event].indexOf(listener);\n\n    if (index > -1) {\n      this._events[event].splice(index, 1);\n    }\n\n    return this;\n  }\n\n  /**\n   * Emits an event.\n   *\n   * @param  {String}       event Name of the event.\n   * @param  {Array}        args  The arguments to apply to the functions bound to this event.\n   * @return {EventManager}       The current instance.\n   */\n  $emit(event, ...args) {\n    if (!Array.isArray(this._events[event])) {\n      return this;\n    }\n\n    this._events[event].forEach((listener) => {\n      listener.apply(this, args);\n    });\n    return this;\n  }\n\n  /**\n   * Bind a listener function to an event for one execution only.\n   *\n   * @param  {String}       event    Name of the event.\n   * @param  {String}       listener Function to be called.\n   * @return {EventManager}          The current instance.\n   */\n  $once(event, listener) {\n    const instance = this;\n    this.$on(event, function handler(...args) {\n      instance.$off(event, handler);\n      listener.apply(instance, args);\n    });\n    return this;\n  }\n}\n", "/**\n * Verbose debug for the component.\n *\n * @param  {...any} args The arguments passed to the method\n * @return {void}\n */\nexport function debug(instance, ...args) {\n  return instance.$options.debug\n    ? window.console.log.apply(window, [instance.config.name, ...args])\n    : () => {};\n}\n\n/**\n * Test if an object has a method.\n *\n * @param  {Object}  obj The object to test\n * @param  {String}  fn  The method's name\n * @return {Boolean}\n */\nexport function hasMethod(obj, name) {\n  return typeof obj[name] === 'function';\n}\n\n/**\n * Call the given method while applying the given arguments.\n *\n * @param {String} method The method to call\n * @param {...any} args   The arguments to pass to the method\n */\nexport function callMethod(instance, method, ...args) {\n  debug(instance, 'callMethod', method, ...args);\n\n  // Prevent duplicate call of `mounted` and `destroyed`\n  // methods based on the component status\n  if (\n    (method === 'destroyed' && !instance.$isMounted) ||\n    (method === 'mounted' && instance.$isMounted)\n  ) {\n    debug(instance, 'not', method, 'because the method has already been triggered once.');\n    return instance;\n  }\n\n  instance.$emit(method, ...args);\n\n  // We always emit an event, but we do not call the method if it does not exist\n  if (!hasMethod(instance, method)) {\n    return instance;\n  }\n\n  instance[method].call(instance, ...args);\n  debug(instance, method, instance, ...args);\n\n  return instance;\n}\n", "/**\n * Get a child component.\n *\n * @param  {HTMLElement}  el             The root element of the child component.\n * @param  {Base|Promise} ComponentClass A Base class or a Promise for async components.\n * @param  {Base}         parent         The parent component instance.\n * @return {Base|Promise}                A Base instance or a Promise resolving to a Base instance.\n */\nfunction getChild(el, ComponentClass, parent) {\n  // Return existing instance if it exists\n  if (el.__base__) {\n    return el.__base__;\n  }\n\n  // Return a new instance if the component class is a child of the Base class\n  if (ComponentClass.__isBase__) {\n    Object.defineProperty(ComponentClass.prototype, '__isChild__', { value: true });\n    const child = new ComponentClass(el);\n    Object.defineProperty(child, '$parent', { get: () => parent });\n    return child;\n  }\n\n  // Resolve async components\n  const asyncComponent = ComponentClass().then((module) => {\n    const ResolvedClass = module.default ? module.default : module;\n    Object.defineProperty(ResolvedClass.prototype, '__isChild__', { value: true });\n    const child = new ResolvedClass(el);\n    Object.defineProperty(child, '$parent', { get: () => parent });\n    return child;\n  });\n\n  asyncComponent.__isAsync__ = true;\n\n  return asyncComponent;\n}\n\n/**\n * Get a list of elements based on the name of a component.\n * @param  {String}             nameOrSelector The name or selector to used for this component.\n * @param  {HTMLElement}        element        The root element on which to query the selector, defaults to `document`.\n * @return {Array<HTMLElement>}                A list of elements on which the component should be mounted.\n */\nexport function getComponentElements(nameOrSelector, element = document) {\n  const selector = `[data-component=\"${nameOrSelector}\"]`;\n  let elements = [];\n\n  try {\n    elements = Array.from(element.querySelectorAll(selector));\n    // eslint-disable-next-line no-empty\n  } catch {}\n\n  // If no child component found with the default selector, try a classic DOM selector\n  if (elements.length === 0) {\n    elements = Array.from(element.querySelectorAll(nameOrSelector));\n  }\n\n  return elements;\n}\n\n/**\n * Get child components.\n * @param  {Base}        instance   The component's instance.\n * @param  {HTMLElement} element    The component's root element\n * @param  {Object}      components The children components' classes\n * @return {null|Object}            Returns `null` if no child components are defined or an object of all child component instances\n */\nexport function getChildren(instance, element, components) {\n  const children = Object.entries(components).reduce((acc, [name, ComponentClass]) => {\n    const elements = getComponentElements(name, element);\n\n    if (elements.length === 0) {\n      return acc;\n    }\n\n    acc[name] = elements\n      .map((el) => getChild(el, ComponentClass, instance))\n      // Filter out terminated children\n      .filter((el) => el !== 'terminated');\n\n    if (acc[name].length === 0) {\n      delete acc[name];\n    }\n\n    return acc;\n  }, {});\n\n  instance.$emit('get:children', children);\n  return children;\n}\n\nexport default {\n  getChildren,\n};\n", "import merge from 'deepmerge';\n\n/**\n * Get a component's options.\n *\n * @param  {Base}        instance The component's instance.\n * @param  {HTMLElement} element  The component's root element.\n * @param  {Object}      config   The component's default config.\n * @return {Object}               The component's merged options.\n */\nexport function getOptions(instance, element, config) {\n  let options = {};\n  if (element.dataset.options) {\n    try {\n      options = JSON.parse(element.dataset.options);\n    } catch (err) {\n      throw new Error('Can not parse the `data-options` attribute. Is it a valid JSON string?');\n    }\n  }\n\n  options = merge(config, options);\n  instance.$emit('get:options', options);\n  return options;\n}\n\n/**\n * Set a component instance options.\n *\n * @param {Base}        instance   The component's instance.\n * @param {HTMLElement} element    The component's root element.\n * @param {Object}      newOptions The new options object.\n */\nexport function setOptions(instance, element, newOptions) {\n  let options = {};\n  if (element.dataset.options) {\n    try {\n      options = JSON.parse(element.dataset.options);\n    } catch (err) {\n      throw new Error('Can not parse the `data-options` attribute. Is it a valid JSON string?');\n    }\n  }\n  options = merge(options, newOptions);\n  element.dataset.options = JSON.stringify(options);\n}\n\nexport default {\n  getOptions,\n  setOptions,\n};\n", "/**\n * A ponyfill for the CSS `:scope` selector which is not supported in IE11.\n * The following method will return an array of elements similare to the\n * `:scope ${selector}` selector.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/:scope\n * @see https://github.com/jonathantneal/element-qsa-scope\n *\n * @param {HTMLElement} element  The element from which the scope is taken.\n * @param {String}      selector The children selector.\n * @param {String}      uniqId   A uniq ID to prefix the selector with.\n */\nexport function scopeSelectorPonyfill(element, selector, uniqId) {\n  const attr = `data-uniq-id`;\n  const scopedSelector = `[${attr}=\"${uniqId}\"] ${selector}`;\n  element.setAttribute(attr, uniqId);\n  const list = Array.from(element.querySelectorAll(scopedSelector));\n  element.removeAttribute(attr);\n  return list;\n}\n\n/**\n * Get all refs of a component.\n *\n * @param  {Base}        instance The component's instance.\n * @param  {HTMLElement} element  The component's root element.\n * @return {Object}               Return an object containing all the component's refs.\n */\nexport function getRefs(instance, element) {\n  const allRefs = Array.from(element.querySelectorAll(`[data-ref]`));\n  const childrenRefs = scopeSelectorPonyfill(element, '[data-component] [data-ref]', instance.$id);\n  const elements = allRefs.filter((ref) => !childrenRefs.includes(ref));\n\n  const refs = elements.reduce(($refs, $ref) => {\n    let refName = $ref.dataset.ref;\n    const $realRef = $ref.__base__ ? $ref.__base__ : $ref;\n\n    if (refName.endsWith('[]')) {\n      refName = refName.replace(/\\[\\]$/, '');\n\n      if (!$refs[refName]) {\n        $refs[refName] = [];\n      }\n    }\n\n    if ($refs[refName]) {\n      if (Array.isArray($refs[refName])) {\n        $refs[refName].push($realRef);\n      } else {\n        $refs[refName] = [$refs[refName], $realRef];\n      }\n    } else {\n      $refs[refName] = $realRef;\n    }\n\n    return $refs;\n  }, {});\n\n  instance.$emit('get:refs', refs);\n  return refs;\n}\n\nexport default {\n  getRefs,\n};\n", "import { debug } from './utils';\n\n/**\n * Mount a given component which might be async.\n *\n * @param  {Base|Promise} component The component to mount.\n * @return {void}\n */\nfunction mountComponent(component) {\n  if (component.__isAsync__) {\n    component.then((instance) => instance.$mount());\n  } else {\n    component.$mount();\n  }\n}\n\n/**\n * Mount children components of a given instance.\n *\n * @param  {Base} instance The parent component's instance.\n * @return {void}\n */\nexport function mountComponents(instance) {\n  if (!instance.$children) {\n    return;\n  }\n\n  debug(instance, 'mountComponents', instance.$children);\n\n  Object.values(instance.$children).forEach(($child) => {\n    $child.forEach(mountComponent);\n  });\n}\n\n/**\n * Destroy a given component which might be async.\n *\n * @param  {Base|Promise} component The component to destroy.\n * @return {void}\n */\nfunction destroyComponent(component) {\n  if (component.__isAsync__) {\n    component.then((instance) => instance.$destroy());\n  } else {\n    component.$destroy();\n  }\n}\n\n/**\n * Destroy children components of a given instance.\n *\n * @param  {Base} instance The parent component's instance.\n * @return {void}\n */\nexport function destroyComponents(instance) {\n  if (!instance.$children) {\n    return;\n  }\n  debug(instance, 'destroyComponents', instance.$children);\n\n  Object.values(instance.$children).forEach(($child) => {\n    $child.forEach(destroyComponent);\n  });\n}\n", "/**\n * Service abstract class\n */\nexport default class Service {\n  /**\n   * Class constructor, used to test the abstract class implementation.\n   *\n   * @return {Service} The current instance\n   */\n  constructor() {\n    this.callbacks = new Map();\n    this.isInit = false;\n  }\n\n  /**\n   * Getter to get the services properties.\n   * This getter MUST be implementer by the service extending this class.\n   * @return {Object}\n   */\n  get props() {\n    throw new Error('The `props` getter must be implemented.');\n  }\n\n  /**\n   * Method to initialize the service behaviors.\n   * This method MUST be implemented by the service extending this class.\n   *\n   * @return {Service} The current instance\n   */\n  init() {\n    throw new Error('The `init` method must be implemented.');\n  }\n\n  /**\n   * Method to kill the service behaviors.\n   * This method MUST be implemented by the service extending this class.\n   *\n   * @return {Service} The current instance\n   */\n  kill() {\n    throw new Error('The `kill` method must be implemented.');\n  }\n\n  /**\n   * Add a callback.\n   *\n   * @param  {String}   key      The callback's identifier\n   * @param  {Function} callback The callback function\n   * @return {Service}           The current instance\n   */\n  add(key, callback) {\n    if (this.has(key)) {\n      throw new Error(`A callback with the key \\`${key}\\` has already been registered.`);\n    }\n\n    // Initialize the service when we add the first callback\n    if (this.callbacks.size === 0 && !this.isInit) {\n      this.init();\n      this.isInit = true;\n    }\n\n    this.callbacks.set(key, callback);\n    return this;\n  }\n\n  /**\n   * Test if a callback with the given key has already been added.\n   *\n   * @param  {String}  key The identifier to test\n   * @return {Boolean}     Whether or not the identifier already exists\n   */\n  has(key) {\n    return this.callbacks.has(key);\n  }\n\n  /**\n   * Get the callback tied to the given key.\n   *\n   * @param  {String}   key The identifier to get\n   * @return {Function}     The callback function\n   */\n  get(key) {\n    return this.callbacks.get(key);\n  }\n\n  /**\n   * Remove the callback tied to the given key.\n   *\n   * @param  {String} key The identifier to remove\n   * @return {Service}    The current instance\n   */\n  remove(key) {\n    this.callbacks.delete(key);\n\n    // Kill the service when we remove the last callback\n    if (this.callbacks.size === 0 && this.isInit) {\n      this.kill();\n      this.isInit = false;\n    }\n\n    return this;\n  }\n\n  /**\n   * Trigger each added callback with the given arguments.\n   *\n   * @param  {Array}   args All the arguments to apply to the callback\n   * @return {Service}      The current instance\n   */\n  trigger(...args) {\n    this.callbacks.forEach((callback) => {\n      callback(...args);\n    });\n\n    return this;\n  }\n}\n", "/**\n * Simple throttling helper that limits a\n * function to only run once every {delay}ms\n *\n * @param {Function} fn    The function to throttle\n * @param {Number}   delay The delay in ms\n */\nexport default function throttle(fn, delay = 16) {\n  let lastCall = 0;\n  return (...args) => {\n    const now = new Date().getTime();\n    if (now - lastCall < delay) {\n      return false;\n    }\n    lastCall = now;\n    return fn(...args);\n  };\n}\n", "/**\n * Returns a function, that, as long as it continues to be invoked,\n * will not be triggered. The function will be called after it stops\n * being called for N milliseconds.\n *\n * @param {Function} fn    The function to call\n * @param {Number}   delay The delay in ms to wait before calling the function\n */\nexport default function debounce(fn, delay = 300) {\n  let timeout;\n  return (...args) => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => {\n      fn(...args);\n    }, delay);\n  };\n}\n", "/**\n * RequestAnimation frame polyfill.\n * @see  https://github.com/vuejs/vue/blob/ec78fc8b6d03e59da669be1adf4b4b5abf670a34/dist/vue.runtime.esm.js#L7355\n * @type {Function}\n */\nexport const getRaf = () =>\n  typeof window !== 'undefined' && window.requestAnimationFrame\n    ? window.requestAnimationFrame.bind(window)\n    : setTimeout;\n\n/**\n * Execute a callback in the next frame.\n * @param  {Function} fn The callback function to execute.\n * @return {Promise}\n */\nexport default function nextFrame(fn = () => {}) {\n  const raf = getRaf();\n  return new Promise((resolve) => {\n    raf(() => raf(() => resolve(fn())));\n  });\n}\n", "import Service from '../abstracts/Service';\nimport { getRaf } from '../utils/nextFrame';\n\n/**\n * Tick service\n *\n * ```\n * import { useRaf } from '@studiometa/js/services';\n * const { add, remove, props } = useRag();\n * add(id, (props) => {});\n * remove(id);\n * props();\n * ```\n */\nclass Raf extends Service {\n  /** @type {Boolean} Whether the loop is running or not. */\n  isTicking = false;\n\n  /**\n   * Start the requestAnimationFrame loop.\n   *\n   * @return {void}\n   */\n  init() {\n    const raf = getRaf();\n\n    const loop = () => {\n      this.trigger(this.props);\n\n      if (!this.isTicking) {\n        return;\n      }\n\n      raf(loop);\n    };\n\n    this.isTicking = true;\n    loop();\n  }\n\n  /**\n   * Stop the requestAnimationFrame loop.\n   *\n   * @return {void}\n   */\n  kill() {\n    this.isTicking = false;\n  }\n\n  /**\n   * Get raf props.\n   *\n   * @todo Return elapsed time / index?\n   * @type {Object}\n   */\n  get props() {\n    return {\n      time: window.performance.now(),\n    };\n  }\n}\n\nlet instance = null;\n\nexport default () => {\n  if (!instance) {\n    instance = new Raf();\n  }\n\n  const add = instance.add.bind(instance);\n  const remove = instance.remove.bind(instance);\n  const has = instance.has.bind(instance);\n  const props = () => instance.props;\n\n  return {\n    add,\n    remove,\n    has,\n    props,\n  };\n};\n", "import Service from '../abstracts/Service';\nimport throttle from '../utils/throttle';\nimport debounce from '../utils/debounce';\nimport useRaf from './raf';\n\n/**\n * Pointer service\n *\n * ```\n * import { usePointer } from '@studiometa/js/services';\n * const { add, remove, props } = usePointer();\n * add(key, (props) => {});\n * remove(key);\n * props();\n * ```\n */\nclass Pointer extends Service {\n  /** @type {Boolean} State of the pointer. */\n  isDown = false;\n\n  /** @type {Number} The y pointer position. */\n  y = window.innerHeight / 2;\n\n  /** @type {Number} The y previous pointer position. */\n  yLast = window.innerHeight / 2;\n\n  /** @type {Number} The x pointer position. */\n  x = window.innerWidth / 2;\n\n  /** @type {Number} The x previous pointer position. */\n  xLast = window.innerWidth / 2;\n\n  /** @type {Event} The latest event emitted from the pointer. */\n  event;\n\n  /**\n   * Bind the handler to the mousemove and touchmove events.\n   * Bind the up and down handler to the mousedown, mouseup, touchstart and touchend events.\n   *\n   * @return {void}\n   */\n  init() {\n    const { add, remove } = useRaf();\n    this.hasRaf = false;\n\n    const debounced = debounce((event) => {\n      this.updateValues(event);\n      remove('usePointer');\n      this.trigger(this.props);\n      this.hasRaf = false;\n    }, 50);\n\n    this.handler = throttle((event) => {\n      this.updateValues(event);\n      if (!this.hasRaf) {\n        add('usePointer', () => {\n          this.trigger(this.props);\n        });\n        this.hasRaf = true;\n      }\n      // Reset changed flags at the end of the mousemove or touchmove event\n      debounced(event);\n    }, 32).bind(this);\n\n    this.downHandler = this.downHandler.bind(this);\n    this.upHandler = this.upHandler.bind(this);\n\n    document.documentElement.addEventListener('mouseenter', this.handler, { once: true });\n    document.addEventListener('mousemove', this.handler, { passive: true });\n    document.addEventListener('touchmove', this.handler, { passive: true });\n    document.addEventListener('mousedown', this.downHandler, { passive: true });\n    document.addEventListener('touchstart', this.downHandler, { passive: true });\n    document.addEventListener('mouseup', this.upHandler, { passive: true });\n    document.addEventListener('touchend', this.upHandler, { passive: true });\n  }\n\n  /**\n   * Unbind all handlers from their bounded event.\n   *\n   * @return {void}\n   */\n  kill() {\n    document.removeEventListener('mousemove', this.handler);\n    document.removeEventListener('touchmove', this.handler);\n    document.removeEventListener('mousedown', this.downHandler);\n    document.removeEventListener('touchstart', this.downHandler);\n    document.removeEventListener('mouseup', this.upHandler);\n    document.removeEventListener('touchend', this.upHandler);\n  }\n\n  /**\n   * Handler for the pointer's down action.\n   *\n   * @return {void}\n   */\n  downHandler() {\n    this.isDown = true;\n    this.trigger(this.props);\n  }\n\n  /**\n   * Handler for the pointer's up action.\n   *\n   * @return {void}\n   */\n  upHandler() {\n    this.isDown = false;\n    this.trigger(this.props);\n  }\n\n  /**\n   * Update the pointer positions.\n   *\n   * @param  {Event} event The event object.\n   * @return {void}\n   */\n  updateValues(event) {\n    this.event = event;\n    this.yLast = this.y;\n    this.xLast = this.x;\n\n    // Check pointer Y\n    // We either get data from a touch event `event.touches[0].clientY` or from\n    // a mouse event `event.clientY`.\n    if (((event.touches || [])[0] || event || {}).clientY !== this.y) {\n      this.y = ((event.touches || [])[0] || event || {}).clientY;\n    }\n\n    // Check pointer X\n    // We either get data from a touch event `event.touches[0].clientX` or from\n    // a mouse event `event.clientX`.\n    if (((event.touches || [])[0] || event || {}).clientX !== this.x) {\n      this.x = ((event.touches || [])[0] || event || {}).clientX;\n    }\n  }\n\n  /**\n   * Get the pointer props.\n   *\n   * @type {Object}\n   */\n  get props() {\n    return {\n      event: this.event,\n      isDown: this.isDown,\n      x: this.x,\n      y: this.y,\n      changed: {\n        x: this.x !== this.xLast,\n        y: this.y !== this.yLast,\n      },\n      last: {\n        x: this.xLast,\n        y: this.yLast,\n      },\n      delta: {\n        x: this.x - this.xLast,\n        y: this.y - this.yLast,\n      },\n      progress: {\n        x: this.x / window.innerWidth,\n        y: this.y / window.innerHeight,\n      },\n      max: {\n        x: window.innerWidth,\n        y: window.innerHeight,\n      },\n    };\n  }\n}\n\nlet pointer = null;\n\n/**\n * Use the pointer.\n *\n * ```js\n * import usePointer from '@studiometa/js-toolkit/services';\n * const { add, remove, props } = usePointer();\n * add('id', () => {});\n * remove('id');\n * props();\n * ```\n */\nexport default () => {\n  if (!pointer) {\n    pointer = new Pointer();\n  }\n\n  const add = pointer.add.bind(pointer);\n  const remove = pointer.remove.bind(pointer);\n  const has = pointer.has.bind(pointer);\n  const props = () => pointer.props;\n\n  return {\n    add,\n    remove,\n    has,\n    props,\n  };\n};\n", "import Service from '../abstracts/Service';\nimport debounce from '../utils/debounce';\n\n/**\n * Resize service\n *\n * ```\n * import { useResize } from '@studiometa/js/services';\n * const { add, remove, props } = useResize();\n * add(key, (props) => {});\n * remove(key);\n * props();\n * ```\n */\nclass Resize extends Service {\n  /**\n   * Bind the handler to the resize event.\n   *\n   * @return {void}\n   */\n  init() {\n    this.handler = debounce(() => {\n      this.trigger(this.props);\n    }).bind(this);\n\n    if (this.canUseResizeObserver) {\n      this.resizeObserver = new ResizeObserver(this.handler);\n      this.resizeObserver.observe(document.documentElement);\n    } else {\n      window.addEventListener('resize', this.handler);\n    }\n  }\n\n  /**\n   * Unbind the handler from the resize event.\n   *\n   * @return {void}\n   */\n  kill() {\n    if (this.canUseResizeObserver) {\n      this.resizeObserver.disconnect();\n    } else {\n      window.removeEventListener('resize', this.handler);\n    }\n    delete this.resizeObserver;\n  }\n\n  /**\n   * Get resize props.\n   *\n   * @type {Object}\n   */\n  get props() {\n    const props = {\n      width: window.innerWidth,\n      height: window.innerHeight,\n      ratio: window.innerWidth / window.innerHeight,\n      orientation: 'square',\n    };\n\n    if (props.ratio > 1) {\n      props.orientation = 'landscape';\n    }\n\n    if (props.ratio < 1) {\n      props.orientation = 'portrait';\n    }\n\n    if (this.breakpointElement) {\n      props.breakpoint = this.breakpoint;\n      props.breakpoints = this.breakpoints;\n    }\n\n    return props;\n  }\n\n  /**\n   * The element holding the breakpoints data.\n   * @return {HTMLElement}\n   */\n  get breakpointElement() {\n    return document.querySelector('[data-breakpoint]') || null;\n  }\n\n  /**\n   * Get the current breakpoint.\n   * @return {String}\n   */\n  get breakpoint() {\n    return window\n      .getComputedStyle(this.breakpointElement, '::before')\n      .getPropertyValue('content')\n      .replace(/\"/g, '');\n  }\n\n  /**\n   * Get all breakpoints.\n   * @return {Array}\n   */\n  get breakpoints() {\n    const breakpoints = window\n      .getComputedStyle(this.breakpointElement, '::after')\n      .getPropertyValue('content')\n      .replace(/\"/g, '');\n\n    return breakpoints.split(',');\n  }\n\n  /**\n   * Test if we can use the `ResizeObserver` API.\n   * @return {Boolean}\n   */\n  get canUseResizeObserver() {\n    return typeof window.ResizeObserver !== 'undefined';\n  }\n}\n\nlet resize = null;\n\nexport default () => {\n  if (!resize) {\n    resize = new Resize();\n  }\n\n  const add = resize.add.bind(resize);\n  const remove = resize.remove.bind(resize);\n  const has = resize.has.bind(resize);\n  const props = () => resize.props;\n\n  return {\n    add,\n    remove,\n    has,\n    props,\n  };\n};\n", "import Service from '../abstracts/Service';\nimport throttle from '../utils/throttle';\nimport debounce from '../utils/debounce';\nimport nextFrame from '../utils/nextFrame';\n\n/**\n * Scroll service\n *\n * ```\n * import { useScroll } from '@studiometa/js-toolkit/services';\n * const { add, remove, props } = useScroll();\n * add(key, (props) => {});\n * remove(key);\n * props();\n * ```\n */\nclass Scroll extends Service {\n  /** @type {Number} The y scroll position. */\n  y = window.pageYOffset;\n\n  /** @type {Number} The y previous scroll position. */\n  yLast = window.pageYOffset;\n\n  /** @type {Number} The x scroll position. */\n  x = window.pageXOffset;\n\n  /** @type {Number} The x previous scroll position. */\n  xLast = window.pageXOffset;\n\n  /**\n   * Bind the handler to the scroll event.\n   *\n   * @return {void}\n   */\n  init() {\n    const debounced = debounce(() => {\n      this.trigger(this.props);\n      nextFrame(() => {\n        this.trigger(this.props);\n      });\n    }, 50);\n\n    this.handler = throttle(() => {\n      this.trigger(this.props);\n\n      // Reset changed flags at the end of the scroll event\n      debounced();\n    }, 32).bind(this);\n\n    // Fire the `scrolled` method on document scroll\n    document.addEventListener('scroll', this.handler, { passive: true });\n  }\n\n  /**\n   * Unbind the handler from the scroll event.\n   *\n   * @return {void}\n   */\n  kill() {\n    document.removeEventListener('scroll', this.handler);\n  }\n\n  /**\n   * Get scroll props.\n   *\n   * @type {Object}\n   */\n  get props() {\n    this.yLast = this.y;\n    this.xLast = this.x;\n\n    // Check scroll Y\n    if (window.pageYOffset !== this.y) {\n      this.y = window.pageYOffset;\n    }\n\n    // Check scroll x\n    if (window.pageXOffset !== this.x) {\n      this.x = window.pageXOffset;\n    }\n\n    return {\n      x: this.x,\n      y: this.y,\n      changed: {\n        x: this.x !== this.xLast,\n        y: this.y !== this.yLast,\n      },\n      last: {\n        x: this.xLast,\n        y: this.yLast,\n      },\n      delta: {\n        x: this.x - this.xLast,\n        y: this.y - this.yLast,\n      },\n      progress: {\n        x: this.max.x === 0 ? 1 : this.x / this.max.x,\n        y: this.max.y === 0 ? 1 : this.y / this.max.y,\n      },\n      max: this.max,\n    };\n  }\n\n  /**\n   * Get scroll max values.\n   *\n   * @type {Object}\n   */\n  get max() {\n    return {\n      x: (document.scrollingElement || document.body).scrollWidth - window.innerWidth,\n      y: (document.scrollingElement || document.body).scrollHeight - window.innerHeight,\n    };\n  }\n}\n\nlet scroll = null;\n\nexport default () => {\n  if (!scroll) {\n    scroll = new Scroll();\n  }\n\n  const add = scroll.add.bind(scroll);\n  const remove = scroll.remove.bind(scroll);\n  const has = scroll.has.bind(scroll);\n  const props = () => scroll.props;\n\n  return {\n    add,\n    remove,\n    has,\n    props,\n  };\n};\n", "export default {\n  ENTER: 13,\n  SPACE: 32,\n  TAB: 9,\n  ESC: 27,\n  LEFT: 37,\n  UP: 38,\n  RIGHT: 39,\n  DOWN: 40,\n};\n", "import Service from '../abstracts/Service';\nimport keyCodes from '../utils/keyCodes';\n\n/**\n * Scroll service\n *\n * ```\n * import { useKey } from '@studiometa/js-toolkit/services';\n * const { add, remove, props } = useKey();\n * add(key, (props) => {});\n * remove(key);\n * props();\n * ```\n */\nclass Key extends Service {\n  /** @type {Object} The event object. */\n  event = {};\n\n  /**\n   * Used to accumulate the number of times the `keydown` event has been triggered.\n   * @type {Number}\n   */\n  triggered = 0;\n\n  /** @type {Object} The previous event object. */\n  previousEvent = {};\n\n  /**\n   * Bind the handler to the keyboard event.\n   *\n   * @return {void}\n   */\n  init() {\n    this.handler = (event) => {\n      this.event = event;\n      this.trigger(this.props);\n    };\n    document.addEventListener('keydown', this.handler, { passive: false });\n    document.addEventListener('keyup', this.handler, { passive: false });\n  }\n\n  /**\n   * Unbind the handler from the keyboard event.\n   *\n   * @return {void}\n   */\n  kill() {\n    document.removeEventListener('keydown', this.handler);\n    document.removeEventListener('keyup', this.handler);\n  }\n\n  /**\n   * Get keyboard props.\n   *\n   * @type {Object}\n   */\n  get props() {\n    const keys = Object.entries(keyCodes).reduce((acc, [name, code]) => {\n      acc[name] = code === this.event.keyCode;\n      return acc;\n    }, {});\n\n    if (!this.previousEvent.type) {\n      this.triggered = 0;\n    }\n\n    if (this.event.type === 'keydown' && this.previousEvent.type === 'keydown') {\n      this.triggered += 1;\n    } else {\n      this.triggered = 1;\n    }\n\n    this.previousEvent = this.event;\n\n    return {\n      event: this.event,\n      triggered: this.triggered,\n      direction: this.event.type === 'keydown' ? 'down' : 'up',\n      isUp: this.event.type === 'keyup',\n      isDown: this.event.type === 'keydown',\n      ...keys,\n    };\n  }\n}\n\nlet key = null;\n\nexport default () => {\n  if (!key) {\n    key = new Key();\n  }\n\n  const add = key.add.bind(key);\n  const remove = key.remove.bind(key);\n  const has = key.has.bind(key);\n  const props = () => key.props;\n\n  return {\n    add,\n    remove,\n    has,\n    props,\n  };\n};\n", "import usePointer from '../../services/pointer';\nimport useRaf from '../../services/raf';\nimport useResize from '../../services/resize';\nimport useScroll from '../../services/scroll';\nimport useKey from '../../services/key';\nimport { hasMethod, callMethod } from './utils';\n\n/**\n * Init the given service and bind it to the given instance.\n *\n * @param  {Base}     instance The Base instance.\n * @param  {String}   method   The instance to test for binding\n * @param  {Function} service  The service `use...` function\n * @return {Function}          A function to unbind the service\n */\nfunction initService(instance, method, service) {\n  if (!hasMethod(instance, method)) {\n    return () => {};\n  }\n\n  const { add, remove } = service();\n  add(instance.$id, (...args) => {\n    callMethod(instance, method, ...args);\n  });\n\n  return () => remove(instance.$id);\n}\n\n/**\n * Use the services.\n * @param  {Base} instance A Base class instance.\n * @return {Array}         A list of unbind methods.\n */\nexport default function bindServices(instance) {\n  const unbindMethods = [\n    initService(instance, 'scrolled', useScroll),\n    initService(instance, 'resized', useResize),\n    initService(instance, 'ticked', useRaf),\n    initService(instance, 'moved', usePointer),\n    initService(instance, 'keyed', useKey),\n  ];\n\n  // Fire the `loaded` method on window load\n  // @todo remove this? or move it elsewhere?\n  if (hasMethod(instance, 'loaded')) {\n    const loadedHandler = (event) => {\n      callMethod(instance, 'loaded', { event });\n    };\n    window.addEventListener('load', loadedHandler);\n    unbindMethods.push(() => {\n      window.removeEventListener('load', loadedHandler);\n    });\n  }\n\n  return unbindMethods;\n}\n", "import getAllProperties from '../../utils/object/getAllProperties';\nimport { debug } from './utils';\n\n/**\n * Bind event handler methods to the root HTML element.\n *\n * @param  {Base}  instance     A Base instance.\n * @param  {Array} eventMethods A list of methods to bind.\n * @return {Array}              A list of unbind functions.\n */\nfunction bindRootEvents(instance, eventMethods) {\n  return eventMethods.map((eventMethod) => {\n    const eventName = eventMethod.replace(/^on/, '').toLowerCase();\n\n    const handler = (...args) => {\n      debug(instance, eventMethod, instance.$el, ...args);\n      instance[eventMethod](...args);\n    };\n\n    instance.$el.addEventListener(eventName, handler);\n\n    return () => {\n      instance.$el.removeEventListener(eventName, handler);\n    };\n  });\n}\n\n/**\n * Bind event handler methods to refs HTML element.\n *\n * @param  {Base}  instance     A Base instance.\n * @param  {Array} eventMethods A list of methods to bind.\n * @return {Array}              A list of unbind functions.\n */\nfunction bindRefsEvents(instance, eventMethods) {\n  const unbindMethods = [];\n\n  Object.entries(instance.$refs).forEach(([refName, $refOrRefs]) => {\n    const $refs = Array.isArray($refOrRefs) ? $refOrRefs : [$refOrRefs];\n    const refEventMethod = `on${refName.replace(/^\\w/, (c) => c.toUpperCase())}`;\n\n    eventMethods\n      .filter((eventMethod) => eventMethod.startsWith(refEventMethod))\n      .forEach((eventMethod) => {\n        $refs.forEach(($ref, index) => {\n          const eventName = eventMethod.replace(refEventMethod, '').toLowerCase();\n          const handler = (...args) => {\n            debug(instance, eventMethod, $ref, ...args, index);\n            instance[eventMethod](...args, index);\n          };\n\n          debug(instance, 'binding ref event', refName, eventName);\n\n          if ($ref.constructor && $ref.constructor.__isBase__) {\n            // eslint-disable-next-line no-param-reassign\n            $ref = $ref.$el;\n          }\n\n          $ref.addEventListener(eventName, handler);\n          const unbindMethod = () => {\n            debug(instance, 'unbinding ref event', eventMethods);\n            $ref.removeEventListener(eventName, handler);\n          };\n\n          unbindMethods.push(unbindMethod);\n        });\n      });\n  });\n\n  return unbindMethods;\n}\n\n/**\n * Bind event handler methods to children Base instance.\n * @param  {Base}  instance     A Base instance.\n * @param  {Array} eventMethods A list of methods to bind.\n * @return {Array}              A list of unbind functions.\n */\nfunction bindChildrenEvents(instance, eventMethods) {\n  const unbindMethods = [];\n\n  Object.entries(instance.$children).forEach(([childName, $children]) => {\n    const childEventMethod = `on${childName.replace(/^\\w/, (c) => c.toUpperCase())}`;\n\n    eventMethods\n      .filter((eventMethod) => eventMethod.startsWith(childEventMethod))\n      .forEach((eventMethod) => {\n        $children.forEach(($child, index) => {\n          const eventName = eventMethod.replace(childEventMethod, '').toLowerCase();\n          const handler = (...args) => {\n            debug(instance, eventMethod, $child, ...args, index);\n            instance[eventMethod](...args, index);\n          };\n\n          debug(instance, 'binding child event', childName, eventName);\n\n          const unbindMethod = $child.$on(eventName, handler);\n          unbindMethods.push(() => {\n            debug(instance, 'unbinding child event', childName, eventName);\n            unbindMethod();\n          });\n        });\n      });\n  });\n\n  return unbindMethods;\n}\n\n/**\n * Bind ref and children component's events to their corresponding method.\n *\n * @param  {Base} instance  A Base instance.\n * @return {Array}          A list of methods to unbind the events.\n */\nexport default function bindEvents(instance) {\n  const ROOT_EVENT_REGEX = /^on[A-Z][a-z]+$/;\n  const REFS_CHILDREN_EVENT_REGEX = /^on([A-Z][a-z]+)([A-Z][a-z]+)+$/;\n\n  // Get all event methods\n  const eventMethods = getAllProperties(instance).reduce(\n    (acc, [name]) => {\n      // Testing camelCase with one word: onEvent.\n      if (ROOT_EVENT_REGEX.test(name)) {\n        acc.root.push(name);\n        return acc;\n      }\n\n      // Testing camelCase with more than two words: onRefEvent.\n      if (REFS_CHILDREN_EVENT_REGEX.test(name)) {\n        acc.refsOrChildren.push(name);\n      }\n\n      return acc;\n    },\n    { root: [], refsOrChildren: [] }\n  );\n\n  const unbindMethods = [\n    ...bindRootEvents(instance, eventMethods.root),\n    ...bindRefsEvents(instance, eventMethods.refsOrChildren),\n    ...bindChildrenEvents(instance, eventMethods.refsOrChildren),\n  ];\n\n  return unbindMethods;\n}\n", "import nanoid from 'nanoid/non-secure';\nimport autoBind from '../../utils/object/autoBind';\nimport EventManager from '../EventManager';\nimport { callMethod, debug } from './utils';\nimport { getChildren, getComponentElements } from './children';\nimport { getOptions, setOptions } from './options';\nimport { getRefs } from './refs';\nimport { mountComponents, destroyComponents } from './components';\nimport bindServices from './services';\nimport bindEvents from './events';\n\n/**\n * Page lifecycle class\n *\n * @method mounted   Fired when the class is instantiated\n * @method loaded    Fired on the window's load event\n * @method ticked    Fired each frame with `requestAnimationFrame`\n * @method resized   Fired when the window is resized (`resize` event)\n * @method moved     Fired when the pointer has moved (`touchmove` and `mousemove` events)\n * @method scrolled  Fired with debounce when the document is scrolled (`scroll` event)\n * @method destroyed Fired when the window is being unloaded (`unload` event)\n */\nexport default class Base extends EventManager {\n  /**\n   * Get the component's refs.\n   * @return {Object}\n   */\n  get $refs() {\n    return getRefs(this, this.$el);\n  }\n\n  /**\n   * Get the component's children components.\n   * @return {Object}\n   */\n  get $children() {\n    return getChildren(this, this.$el, this.config.components || {});\n  }\n\n  /**\n   * Get the component's merged config and options.\n   * @return {Object}\n   */\n  get $options() {\n    return getOptions(this, this.$el, this.config);\n  }\n\n  /**\n   * Set the components option.\n   * @param  {Object} value The new options values to merge with the old ones.\n   * @return {void}\n   */\n  set $options(newOptions) {\n    setOptions(this, this.$el, newOptions);\n  }\n\n  /**\n   * Class constructor where all the magic takes place.\n   *\n   * @param  {HTMLElement} element The component's root element.\n   * @return {Base}                A Base instance.\n   */\n  constructor(element) {\n    super();\n\n    if (!this.config) {\n      throw new Error('The `config` getter must be defined.');\n    }\n\n    if (!this.config.name) {\n      throw new Error('The `config.name` property is required.');\n    }\n\n    if (!element) {\n      throw new Error('The root element must be defined.');\n    }\n\n    Object.defineProperties(this, {\n      $id: {\n        value: `${this.config.name}-${nanoid()}`,\n      },\n      $isMounted: {\n        value: false,\n        writable: true,\n      },\n      $el: {\n        value: element,\n      },\n    });\n\n    if (!this.$el.__base__) {\n      Object.defineProperty(this.$el, '__base__', {\n        get: () => this,\n        configurable: true,\n      });\n    }\n\n    // Autobind all methods to the instance\n    autoBind(this, {\n      exclude: [\n        '$mount',\n        '$update',\n        '$destroy',\n        '$terminate',\n        '$log',\n        '$on',\n        '$once',\n        '$off',\n        '$emit',\n        'mounted',\n        'loaded',\n        'ticked',\n        'resized',\n        'moved',\n        'keyed',\n        'scrolled',\n        'destroyed',\n        'terminated',\n        ...(this._excludeFromAutoBind || []),\n      ],\n    });\n\n    let unbindMethods = [];\n    this.$on('mounted', () => {\n      mountComponents(this);\n      unbindMethods = [...bindServices(this), ...bindEvents(this)];\n      this.$isMounted = true;\n    });\n\n    this.$on('updated', () => {\n      unbindMethods.forEach((method) => method());\n      mountComponents(this);\n      unbindMethods = [...bindServices(this), ...bindEvents(this)];\n    });\n\n    this.$on('destroyed', () => {\n      this.$isMounted = false;\n      unbindMethods.forEach((method) => method());\n      destroyComponents(this);\n    });\n\n    // Mount class which are not used as another component's child.\n    if (!this.__isChild__) {\n      this.$mount();\n      Object.defineProperty(this, '$parent', { get: () => null });\n    }\n\n    debug(this, 'constructor', this);\n    return this;\n  }\n\n  /**\n   * Small helper to log stuff.\n   *\n   * @param  {...any} args The arguments passed to the method\n   * @return {void}\n   */\n  $log(...args) {\n    return this.$options.log\n      ? window.console.log.apply(window, [this.config.name, ...args])\n      : () => {};\n  }\n\n  /**\n   * Trigger the `mounted` callback.\n   */\n  $mount() {\n    debug(this, '$mount');\n    callMethod(this, 'mounted');\n    return this;\n  }\n\n  /**\n   * Update the instance children.\n   */\n  $update() {\n    debug(this, '$update');\n    callMethod(this, 'updated');\n    return this;\n  }\n\n  /**\n   * Trigger the `destroyed` callback.\n   */\n  $destroy() {\n    debug(this, '$destroy');\n    callMethod(this, 'destroyed');\n    return this;\n  }\n\n  /**\n   * Terminate a child instance when it is not needed anymore.\n   * @return {void}\n   */\n  $terminate() {\n    debug(this, '$terminate');\n\n    // First, destroy the component.\n    this.$destroy();\n\n    // Execute the `terminated` hook if it exists\n    callMethod(this, 'terminated');\n\n    // Delete the reference to the instance\n    delete this.$el.__base__;\n\n    // And update its status to prevent re-instantiation when accessing the\n    // parent's `$children` property\n    Object.defineProperty(this.$el, '__base__', {\n      value: 'terminated',\n      configurable: false,\n      writable: false,\n    });\n  }\n\n  /**\n   * Factory method to generate multiple instance of the class.\n   *\n   * @param  {String}      selector The selector on which to mount each instance.\n   * @return {Array<Base>}          A list of the created instance.\n   */\n  static $factory(nameOrSelector) {\n    if (!nameOrSelector) {\n      throw new Error(\n        'The $factory method requires a component\u2019s name or selector to be specified.'\n      );\n    }\n\n    return getComponentElements(nameOrSelector).map((el) => new this(el));\n  }\n}\n\nBase.__isBase__ = true;\n", "import nanoid from 'nanoid/non-secure';\nimport autoBind from '../../utils/object/autoBind';\nimport EventManager from '../EventManager';\nimport { callMethod, debug } from './utils';\nimport { getChildren, getComponentElements } from './children';\nimport { getOptions, setOptions } from './options';\nimport { getRefs } from './refs';\nimport { mountComponents, destroyComponents } from './components';\nimport bindServices from './services';\nimport bindEvents from './events';\n\n/**\n * Page lifecycle class\n *\n * @method mounted   Fired when the class is instantiated\n * @method loaded    Fired on the window's load event\n * @method ticked    Fired each frame with `requestAnimationFrame`\n * @method resized   Fired when the window is resized (`resize` event)\n * @method moved     Fired when the pointer has moved (`touchmove` and `mousemove` events)\n * @method scrolled  Fired with debounce when the document is scrolled (`scroll` event)\n * @method destroyed Fired when the window is being unloaded (`unload` event)\n */\nexport default class Base extends EventManager {\n  /**\n   * Get the component's refs.\n   * @return {Object}\n   */\n  get $refs() {\n    return getRefs(this, this.$el);\n  }\n\n  /**\n   * Get the component's children components.\n   * @return {Object}\n   */\n  get $children() {\n    return getChildren(this, this.$el, this.config.components || {});\n  }\n\n  /**\n   * Get the component's merged config and options.\n   * @return {Object}\n   */\n  get $options() {\n    return getOptions(this, this.$el, this.config);\n  }\n\n  /**\n   * Set the components option.\n   * @param  {Object} value The new options values to merge with the old ones.\n   * @return {void}\n   */\n  set $options(newOptions) {\n    setOptions(this, this.$el, newOptions);\n  }\n\n  /**\n   * Class constructor where all the magic takes place.\n   *\n   * @param  {HTMLElement} element The component's root element.\n   * @return {Base}                A Base instance.\n   */\n  constructor(element) {\n    super();\n\n    if (!this.config) {\n      throw new Error('The `config` getter must be defined.');\n    }\n\n    if (!this.config.name) {\n      throw new Error('The `config.name` property is required.');\n    }\n\n    if (!element) {\n      throw new Error('The root element must be defined.');\n    }\n\n    Object.defineProperties(this, {\n      $id: {\n        value: `${this.config.name}-${nanoid()}`,\n      },\n      $isMounted: {\n        value: false,\n        writable: true,\n      },\n      $el: {\n        value: element,\n      },\n    });\n\n    if (!this.$el.__base__) {\n      Object.defineProperty(this.$el, '__base__', {\n        get: () => this,\n        configurable: true,\n      });\n    }\n\n    // Autobind all methods to the instance\n    autoBind(this, {\n      exclude: [\n        '$mount',\n        '$update',\n        '$destroy',\n        '$terminate',\n        '$log',\n        '$on',\n        '$once',\n        '$off',\n        '$emit',\n        'mounted',\n        'loaded',\n        'ticked',\n        'resized',\n        'moved',\n        'keyed',\n        'scrolled',\n        'destroyed',\n        'terminated',\n        ...(this._excludeFromAutoBind || []),\n      ],\n    });\n\n    let unbindMethods = [];\n    this.$on('mounted', () => {\n      mountComponents(this);\n      unbindMethods = [...bindServices(this), ...bindEvents(this)];\n      this.$isMounted = true;\n    });\n\n    this.$on('updated', () => {\n      unbindMethods.forEach((method) => method());\n      mountComponents(this);\n      unbindMethods = [...bindServices(this), ...bindEvents(this)];\n    });\n\n    this.$on('destroyed', () => {\n      this.$isMounted = false;\n      unbindMethods.forEach((method) => method());\n      destroyComponents(this);\n    });\n\n    // Mount class which are not used as another component's child.\n    if (!this.__isChild__) {\n      this.$mount();\n      Object.defineProperty(this, '$parent', { get: () => null });\n    }\n\n    debug(this, 'constructor', this);\n    return this;\n  }\n\n  /**\n   * Small helper to log stuff.\n   *\n   * @param  {...any} args The arguments passed to the method\n   * @return {void}\n   */\n  $log(...args) {\n    return this.$options.log\n      ? window.console.log.apply(window, [this.config.name, ...args])\n      : () => {};\n  }\n\n  /**\n   * Trigger the `mounted` callback.\n   */\n  $mount() {\n    debug(this, '$mount');\n    callMethod(this, 'mounted');\n    return this;\n  }\n\n  /**\n   * Update the instance children.\n   */\n  $update() {\n    debug(this, '$update');\n    callMethod(this, 'updated');\n    return this;\n  }\n\n  /**\n   * Trigger the `destroyed` callback.\n   */\n  $destroy() {\n    debug(this, '$destroy');\n    callMethod(this, 'destroyed');\n    return this;\n  }\n\n  /**\n   * Terminate a child instance when it is not needed anymore.\n   * @return {void}\n   */\n  $terminate() {\n    debug(this, '$terminate');\n\n    // First, destroy the component.\n    this.$destroy();\n\n    // Execute the `terminated` hook if it exists\n    callMethod(this, 'terminated');\n\n    // Delete the reference to the instance\n    delete this.$el.__base__;\n\n    // And update its status to prevent re-instantiation when accessing the\n    // parent's `$children` property\n    Object.defineProperty(this.$el, '__base__', {\n      value: 'terminated',\n      configurable: false,\n      writable: false,\n    });\n  }\n\n  /**\n   * Factory method to generate multiple instance of the class.\n   *\n   * @param  {String}      selector The selector on which to mount each instance.\n   * @return {Array<Base>}          A list of the created instance.\n   */\n  static $factory(nameOrSelector) {\n    if (!nameOrSelector) {\n      throw new Error(\n        'The $factory method requires a component\u2019s name or selector to be specified.'\n      );\n    }\n\n    return getComponentElements(nameOrSelector).map((el) => new this(el));\n  }\n}\n\nBase.__isBase__ = true;\n", "import Base from './abstracts/Base';\n\n/**\n * Define a component without a class.\n *\n * @param  {Object} options The component's object\n * @return {Base}           A component's class.\n */\nexport function defineComponent(options) {\n  const { config, methods, ...hooks } = options;\n\n  if (!config) {\n    throw new Error('The `config` property is required.');\n  }\n\n  if (!config.name) {\n    throw new Error('The `config.name` property is required.');\n  }\n\n  /**\n   * Component class.\n   */\n  class Component extends Base {\n    /**\n     * Component config.\n     */\n    get config() {\n      return config;\n    }\n  }\n\n  const allowedHooks = [\n    'mounted',\n    'loaded',\n    'ticked',\n    'resized',\n    'moved',\n    'keyed',\n    'scrolled',\n    'destroyed',\n    'terminated',\n  ];\n\n  const filteredHooks = Object.entries(hooks).reduce((acc, [name, fn]) => {\n    if (allowedHooks.includes(name)) {\n      acc[name] = fn;\n    } else {\n      throw new Error(\n        `\n          The \"${name}\" method is not a Base lifecycle hook,\n          it should be placed in the \"method\" property.\n          The following hooks are available: ${allowedHooks.join(', ')}\n        `\n      );\n    }\n\n    return acc;\n  }, {});\n\n  [...Object.entries(methods || {}), ...Object.entries(filteredHooks)].forEach(([name, fn]) => {\n    Component.prototype[name] = fn;\n  });\n\n  return Component;\n}\n\n/**\n * Create a Base instance with the given object configuration.\n * @param {HTMLElement|String} elementOrSelector The instance root HTML element.\n * @param {Object}             options           The Base class configuration.\n */\nexport function createBase(elementOrSelector, options) {\n  const Component = defineComponent(options);\n  const element =\n    typeof elementOrSelector === 'string'\n      ? document.querySelector(elementOrSelector)\n      : elementOrSelector;\n  return new Component(element);\n}\n\nexport default Base;\n"],
  "mappings": "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",
  "names": []
}
